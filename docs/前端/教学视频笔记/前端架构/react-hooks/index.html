<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 4.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:new URL("http://note.niubishanshan.top").hostname,root:"/",scheme:"Gemini",version:"7.7.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{appID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},path:"search.json",motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}}}</script><meta name="description" content="解决的问题 React Hooks 解决了组件之间复用状态逻辑困难, 可能要使用到 HOC or Render Props 这样的特性改变了组件的层级, 而 Hooks 可以在无需修改组件结构的情况下复用状态逻辑 对于复杂的组件进行解耦, Hooks 将组件中相互关联的部分拆分成更小的函数 妈妈再也不用担心我找不准 this 了, 因为没有 this 了  注意事项 只能在函数最外层调用 hook"><meta property="og:type" content="article"><meta property="og:title" content="基础使用 hooks"><meta property="og:url" content="http://note.niubishanshan.top/%E5%89%8D%E7%AB%AF/%E6%95%99%E5%AD%A6%E8%A7%86%E9%A2%91%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84/react-hooks/index.html"><meta property="og:site_name" content="圈圈的随手笔记"><meta property="og:description" content="解决的问题 React Hooks 解决了组件之间复用状态逻辑困难, 可能要使用到 HOC or Render Props 这样的特性改变了组件的层级, 而 Hooks 可以在无需修改组件结构的情况下复用状态逻辑 对于复杂的组件进行解耦, Hooks 将组件中相互关联的部分拆分成更小的函数 妈妈再也不用担心我找不准 this 了, 因为没有 this 了  注意事项 只能在函数最外层调用 hook"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2020-05-05T06:20:31.000Z"><meta property="article:modified_time" content="2021-03-24T12:43:00.020Z"><meta property="article:author" content="圈圈的圈"><meta property="article:tag" content="React"><meta property="article:tag" content="hook"><meta name="twitter:card" content="summary"><link rel="canonical" href="http://note.niubishanshan.top/%E5%89%8D%E7%AB%AF/%E6%95%99%E5%AD%A6%E8%A7%86%E9%A2%91%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84/react-hooks/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0}</script><title>基础使用 hooks | 圈圈的随手笔记</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="圈圈的随手笔记" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div> <a href="https://github.com/luoquanquan" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513;color:#fff;position:absolute;top:0;border:0;right:0" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">圈圈的随手笔记</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">路漫漫其修远兮, 吾将上下而求索</p></div><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i> 首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i> 归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i> 关于</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="site-search"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="搜索..." spellcheck="false" type="text" id="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"></div></div><div class="search-pop-overlay"></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content"><div class="posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://note.niubishanshan.top/%E5%89%8D%E7%AB%AF/%E6%95%99%E5%AD%A6%E8%A7%86%E9%A2%91%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84/react-hooks/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpeg"><meta itemprop="name" content="圈圈的圈"><meta itemprop="description" content="技术学习, 读书笔记, 生活感悟~"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="圈圈的随手笔记"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> 基础使用 hooks</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-05-05 14:20:31" itemprop="dateCreated datePublished" datetime="2020-05-05T14:20:31+08:00">2020-05-05</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2021-03-24 20:43:00" itemprop="dateModified" datetime="2021-03-24T20:43:00+08:00">2021-03-24</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a></span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>1.8k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span>2 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h2><ul><li>React Hooks 解决了组件之间复用状态逻辑困难, 可能要使用到 HOC or Render Props 这样的特性改变了组件的层级, 而 Hooks 可以在无需修改组件结构的情况下复用状态逻辑</li><li>对于复杂的组件进行解耦, Hooks 将组件中相互关联的部分拆分成更小的函数</li><li>妈妈再也不用担心我找不准 this 了, 因为没有 this 了</li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>只能在函数最外层调用 hook, 不能在循环 / 条件判断 / 或者其他子函数中调用</li><li>只能在 React 函数组件中调用, 不能在其他 js 函数中调用</li></ul><h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><h3 id="每次渲染都是一个独立的闭包"><a href="#每次渲染都是一个独立的闭包" class="headerlink" title="每次渲染都是一个独立的闭包"></a>每次渲染都是一个独立的闭包</h3><ul><li>每次渲染都有它自己的 props 和 state</li><li>每次渲染都有自己的事件处理函数</li><li>事件处理函数能获取的是触发时的状态</li><li>组件每次渲染都会被调用, 每次调用中状态值都是一个常量. 并且赋予了当前渲染中的状态值</li><li>单次渲染周期内, props 和 state 的值不变</li></ul><h3 id="惰性初始-state"><a href="#惰性初始-state" class="headerlink" title="惰性初始 state"></a>惰性初始 state</h3><ul><li>initState 的值只有在初始渲染时生效, 后续渲染的过程中会忽略该值</li><li>如果初始的 state 需要经过复杂的函数计算获得, 则可以传入一个函数, 在函数中计算并返回初始的 state. 此函数只有在初次渲染时执行</li><li>和 class 组件的 setState 不同, useState 返回的状态设置函数不会自动合并更新的对象, 需要使用 setState 接收回调函数的方式并利用展开运算符打到合并并更新状态的效果.</li></ul><h3 id="state-比对"><a href="#state-比对" class="headerlink" title="state 比对"></a>state 比对</h3><p>调用 state hook 的设置函数时, 如果传入的 state 的值和当前的 state 值相等, React 会跳过组件的渲染以及 Effect 的执行(状态的对比使用了 Object.is)</p><h2 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h2><ul><li>把创建函数和依赖项数组作为参数传递一个 useMemo, 仅仅会在某个依赖项改变时候才会重新计算 memoized 的值, 这样可以避免每次渲染都进行有开销的计算工作</li></ul><h2 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h2><ul><li>把内联函数以及其依赖项数组作为参数传递给 useCallback, 能够获取一个 memoized 版本的回调函数, 该回调函数仅仅会在某个依赖项改变的时候才会更新</li></ul><h2 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h2><ul><li>useState 是 useReducer 的语法糖, 他接收一个 (state, action) =&gt; newState 的 reducer, 并返回当前的 state 和一个与其配套的 dispatch 方法</li><li>面对 state 逻辑较复杂且包含多个子值, 或者下一个 state 依赖之前的 state 的情况时, useReducer 更加适用</li></ul><h2 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h2><ul><li>接收一个 context 对象, 并返回该 context 对象的当前值</li><li>当前 context 的值由上层组件中距离当前组件最近的 context.Provider 的 value props 决定</li><li>当前组件最近的 context.Provider 的 value props 决定改变时会触发组件的重新渲染</li><li>useContext 相当于 class 组件中的 static contextType 或者函数组件中的 MyContext.Consumer</li></ul><h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><ul><li>函数组件都是纯函数, 所以在函数组件内部不能进行诸如操作 DOM, 添加订阅, 启动定时器等有副作用的操作…</li><li>使用 useEffect 完成副作用操作, 传递给 useEffect 的回调函数会在组件完全渲染到屏幕之后执行, 为函数式组件提供了副作用的能力</li></ul><h2 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h2><p>可以避免多次创建 ref 对象</p><h2 id="useMemo-useCallback-useRef"><a href="#useMemo-useCallback-useRef" class="headerlink" title="useMemo useCallback useRef"></a>useMemo useCallback useRef</h2><ul><li>useMemo useCallback useRef 本质上都是为了缓存</li><li>在以前的类组件中, 类组件就是一个实例, 实例一旦创建其属性就得以保持</li><li>hook 只能使用在函数组件里, 但是函数组件不会创建实例. 当然就没有办法在挂载各种属性,因此就要依靠 useMemo useCallback useRef</li></ul><h2 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h2><ul><li>useImperativeHandle 可以赋予用户在使用 ref 时自定义暴露给父组件的实例的值</li><li>useImperativeHandle 一般与 forwardRef 一起使用</li></ul><h2 id="自定义-hook"><a href="#自定义-hook" class="headerlink" title="自定义 hook"></a>自定义 hook</h2><ul><li>不增加组件的前提下实现组件间重用一些状态逻辑</li><li>hook 是一种复用状态逻辑的方式, 它不能复用状态本身, 每次调用 hook 都会生成一个完全独立的 state</li><li>自定义 hook 更像是一种约定而不是一个功能, 如果函数名义 use 开头, 而且调用了其他的 hook. 那么就认为他是一个自定义的 hook</li></ul></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/React/" rel="tag"># React</a> <a href="/tags/hook/" rel="tag"># hook</a></div><div class="post-nav"><div class="post-nav-item"><a href="/%E4%B8%9A%E4%BD%99%E7%88%B1%E5%A5%BD/%E6%95%99%E5%AD%A6%E8%A7%86%E9%A2%91%E7%AC%94%E8%AE%B0/PS%20%E5%AD%A6%E4%B9%A0/%E8%B6%85%E7%BA%A7%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84ps%E6%95%99%E7%A8%8B/%E5%9F%BA%E7%A1%80%E8%AF%BE/" rel="prev" title="PS 基础课"><i class="fa fa-chevron-left"></i> PS 基础课</a></div><div class="post-nav-item"> <a href="/%E5%89%8D%E7%AB%AF/tips/position-fixed-%E5%A4%B1%E6%95%88/" rel="next" title="position fixed 失效">position fixed 失效<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div><script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#解决的问题"><span class="nav-text">解决的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#注意事项"><span class="nav-text">注意事项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#useState"><span class="nav-text">useState</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#每次渲染都是一个独立的闭包"><span class="nav-text">每次渲染都是一个独立的闭包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#惰性初始-state"><span class="nav-text">惰性初始 state</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#state-比对"><span class="nav-text">state 比对</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#useMemo"><span class="nav-text">useMemo</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#useCallback"><span class="nav-text">useCallback</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#useReducer"><span class="nav-text">useReducer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#useContext"><span class="nav-text">useContext</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#useEffect"><span class="nav-text">useEffect</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#useRef"><span class="nav-text">useRef</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#useMemo-useCallback-useRef"><span class="nav-text">useMemo useCallback useRef</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#useImperativeHandle"><span class="nav-text">useImperativeHandle</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义-hook"><span class="nav-text">自定义 hook</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="圈圈的圈" src="/images/avatar.jpeg"><p class="site-author-name" itemprop="name">圈圈的圈</p><div class="site-description" itemprop="description">技术学习, 读书笔记, 生活感悟~</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">51</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">9</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">36</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://juejin.im/user/5837c2bd61ff4b006ca8d1b2" title="掘金 → https:&#x2F;&#x2F;juejin.im&#x2F;user&#x2F;5837c2bd61ff4b006ca8d1b2" rel="noopener" target="_blank"><i class="fa fa-fw fa-stack-overflow"></i> 掘金</a></span><span class="links-of-author-item"><a href="https://github.com/luoquanquan" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;luoquanquan" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:luo_quanquan@163.com" title="E-Mail → mailto:luo_quanquan@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i> E-Mail</a></span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-fw fa-rss"></i> RSS</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="http://www.beian.miit.gov.cn/" rel="noopener" target="_blank">京ICP备17034706号-1</a></div><div class="copyright"> &copy; <span itemprop="copyrightYear">2021</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">圈圈的圈</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-area-chart"></i></span> <span title="站点总字数">79k</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span title="站点阅读时长">1:12</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span> <span class="post-meta-divider">|</span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/js/theme-next-canvas-nest/canvas-nest.min.js"></script><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script></body></html>