<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 4.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:new URL("http://note.niubishanshan.top").hostname,root:"/",scheme:"Gemini",version:"7.7.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{appID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},path:"search.json",motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}}}</script><meta name="description" content="概念 如果一个函数的参数是另一个函数, 那么可以称这个函数为高阶函数. 回调函数就是高阶函数的一种实现 如果一个函数的返回值是另一个函数, 那么也可以成该函数为高阶函数. 闭包  闭包概念: 一个函数不在定义自己的作用域内执行且能获取到该作用域的变量的情况就是闭包"><meta property="og:type" content="article"><meta property="og:title" content="1. 高阶函数"><meta property="og:url" content="http://note.niubishanshan.top/%E5%89%8D%E7%AB%AF/%E6%95%99%E5%AD%A6%E8%A7%86%E9%A2%91%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84/1.%20%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/index.html"><meta property="og:site_name" content="圈圈的随手笔记"><meta property="og:description" content="概念 如果一个函数的参数是另一个函数, 那么可以称这个函数为高阶函数. 回调函数就是高阶函数的一种实现 如果一个函数的返回值是另一个函数, 那么也可以成该函数为高阶函数. 闭包  闭包概念: 一个函数不在定义自己的作用域内执行且能获取到该作用域的变量的情况就是闭包"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2020-03-16T06:20:31.000Z"><meta property="article:modified_time" content="2021-03-16T08:54:48.114Z"><meta property="article:author" content="圈圈的圈"><meta property="article:tag" content="前端架构"><meta property="article:tag" content="学习笔记"><meta name="twitter:card" content="summary"><link rel="canonical" href="http://note.niubishanshan.top/%E5%89%8D%E7%AB%AF/%E6%95%99%E5%AD%A6%E8%A7%86%E9%A2%91%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84/1.%20%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0}</script><title>1. 高阶函数 | 圈圈的随手笔记</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="圈圈的随手笔记" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div> <a href="https://github.com/luoquanquan" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513;color:#fff;position:absolute;top:0;border:0;right:0" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">圈圈的随手笔记</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">路漫漫其修远兮, 吾将上下而求索</p></div><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i> 首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i> 归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i> 关于</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="site-search"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="搜索..." spellcheck="false" type="text" id="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"></div></div><div class="search-pop-overlay"></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content"><div class="posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://note.niubishanshan.top/%E5%89%8D%E7%AB%AF/%E6%95%99%E5%AD%A6%E8%A7%86%E9%A2%91%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84/1.%20%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpeg"><meta itemprop="name" content="圈圈的圈"><meta itemprop="description" content="技术学习, 读书笔记, 生活感悟~"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="圈圈的随手笔记"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> 1. 高阶函数</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-03-16 14:20:31" itemprop="dateCreated datePublished" datetime="2020-03-16T14:20:31+08:00">2020-03-16</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2021-03-16 16:54:48" itemprop="dateModified" datetime="2021-03-16T16:54:48+08:00">2021-03-16</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a></span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>3.9k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span>4 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>如果一个函数的参数是另一个函数, 那么可以称这个函数为高阶函数. 回调函数就是高阶函数的一种实现</li><li>如果一个函数的返回值是另一个函数, 那么也可以成该函数为高阶函数. 闭包</li></ul><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>概念: 一个函数不在定义自己的作用域内执行且能获取到该作用域的变量的情况就是闭包</p><a id="more"></a><h3 id="保存变量"><a href="#保存变量" class="headerlink" title="保存变量"></a>保存变量</h3><p>使用闭包可以访问函数定义时所在作用域的特性可以起到保存变量的作用</p><p>在 js 中判断一个变量类型的方式有以下几种</p><ul><li>typeof 判断直接类型数据的类型, 但是不能详细区分引用类型的值</li><li>instanceof 判断变量是不是某个构造函数的实例, 利用了 obj.__proto__ 和构造函数的原型对比, 只要 __proto__ 属性链上存在构造函数的原型对象就算是 true, 不精准. 存在跨文档判断失效的问题</li><li>Object.prototype.toString.call() 精准判断…</li></ul><h4 id="封装类型判断的函数"><a href="#封装类型判断的函数" class="headerlink" title="封装类型判断的函数"></a>封装类型判断的函数</h4><p>利用 Object.prototype.toString.call 方法包装下可以得到以下方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isType</span>(<span class="params">type, content</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(content) === <span class="string">`[object <span class="subst">$&#123;type&#125;</span>]`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isType(<span class="string">'String'</span>, <span class="string">'-'</span>)</span><br></pre></td></tr></table></figure><p>如果有多个变量需要判断类型的话, 每次判断都需要写入 <code>String</code> 这个类型标记, 冗余. 故升级为一下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isType</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">content</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(content) === <span class="string">`[object <span class="subst">$&#123;type&#125;</span>]`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isString = isType(<span class="string">'String'</span>)</span><br><span class="line">isString(<span class="string">'-'</span>)</span><br></pre></td></tr></table></figure><p>上述代码中利用了 <code>isType</code> 方法创建了一个闭包, 用于保存 <code>String</code> 这个类型值. 并返回了判断类型的函数. 命名为 <code>isString</code> 后续所有的判断字符串型的数据只需要调用 <code>isString(&#39;-&#39;)</code> 无需每次在写入 <code>String</code> 类型值</p><h3 id="保护局部变量"><a href="#保护局部变量" class="headerlink" title="保护局部变量"></a>保护局部变量</h3><p>根据闭包函数能够访问到创建它的时候的作用域的特性, 可以在创建函数的作用域定义私有变量. 如下代码中, 全局和函数作用域中都定义了 name 变量虽然全局作用域中的 name 变量重新赋值了, 但是并不影响闭包中获取局部变量~ 实现了保护局部变量不受外部影响</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'global'</span></span><br><span class="line"><span class="keyword">var</span> quanquan = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">'quanquan'</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        sayName() &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(name)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line">quanquan.sayName()</span><br><span class="line">name = <span class="string">'new - global'</span></span><br><span class="line">quanquan.sayName()</span><br></pre></td></tr></table></figure><h2 id="柯里化-反柯里化"><a href="#柯里化-反柯里化" class="headerlink" title="柯里化 | 反柯里化"></a>柯里化 | 反柯里化</h2><h3 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h3><p>官方解释:<br>柯里化是把接受多个参数的函数变换成一个接受单一参数(原始函数的第一个参数)的函数, 并且返回接受余下的参数而且返回结果的新函数的技术.</p><p>通俗解释:<br>Currying 就是只给函数传递部分参数来调用它, 并让他返回一个函数去处理剩下的参数的过程.</p><p>简单的实现如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>)) <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">const</span> curryingAdd = <span class="function"><span class="params">a</span> =&gt;</span> <span class="function"><span class="params">b</span> =&gt;</span> a + b</span><br><span class="line">curryingAdd(<span class="number">1</span>)(<span class="number">2</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>以上代码就是把一个原本接收 a, b 两个参数的函数转变成了先用一个函数处理 a 参数, 并返回一个函数可以处理 b 参数, 有啥用呢…</p><h4 id="函数柯里化的作用"><a href="#函数柯里化的作用" class="headerlink" title="函数柯里化的作用"></a>函数柯里化的作用</h4><ul><li>参数复用</li><li>延迟执行</li><li>提前求值</li></ul><h5 id="参数复用"><a href="#参数复用" class="headerlink" title="参数复用"></a>参数复用</h5><p>正如本文开始的例子, <code>isType</code> 需要接收 type 和 content 两个参数, 且相同类型的判断 type 值的类型不会变化的. 所以, 可以升级 <code>isType</code> 为 <code>isString</code> 后续使用时直接使用 <code>isString(需要判断类型的变量)</code> 即可, 实现了 type 参数的复用</p><h5 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h5><p>eg: Function.prototype.bind 的使用, 就是一个延迟执行的体现</p><h5 id="提前求值"><a href="#提前求值" class="headerlink" title="提前求值"></a>提前求值</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> on = <span class="function"><span class="keyword">function</span>(<span class="params">element, event, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.addEventListener) &#123;</span><br><span class="line">        <span class="keyword">if</span> (element &amp;&amp; event &amp;&amp; handler) &#123;</span><br><span class="line">            element.addEventListener(event, handler, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (element &amp;&amp; event &amp;&amp; handler) &#123;</span><br><span class="line">            element.attachEvent(<span class="string">'on'</span> + event, handler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Currying…</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> on = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.addEventListener) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">element, event, handler</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (element &amp;&amp; event &amp;&amp; handler) &#123;</span><br><span class="line">                element.addEventListener(event, handler, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">element, event, handler</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (element &amp;&amp; event &amp;&amp; handler) &#123;</span><br><span class="line">                element.attachEvent(<span class="string">'on'</span> + event, handler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>这里相当于把当前浏览器是否支持 <code>document.addEventListener</code> 作为了一个已知的参数. 通过自运行函数对 on 先行赋值. 而不用每次绑定事件时候再做判断</p><h3 id="反柯里化"><a href="#反柯里化" class="headerlink" title="反柯里化"></a>反柯里化</h3><p>反柯里化是一个泛型化的过程, 被反柯里化的函数可以接收更多参数. 目的是创建一个更普适性的函数, 可以被不同的对象使用.</p><p>还是使用类型判断的例子, 由于我们判断的内容可能是各种类型, 想要利用 <code>Object.prototype.toString</code> 必须<br><code>Object.prototype.toString.call(待判断的变量)</code> 有没有可能让待判断的变量可以直接执行 <code>toString</code> 方法呢? 似乎符合上述的反柯里化的定义~</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unCurrying = <span class="function"><span class="params">fn</span> =&gt;</span> <span class="function"><span class="params">content</span> =&gt;</span> fn.call(content)</span><br><span class="line"><span class="keyword">const</span> toString = unCurrying(<span class="built_in">Object</span>.prototype.toString)</span><br><span class="line"></span><br><span class="line">toString(<span class="string">'-'</span>)    <span class="comment">// [object String]</span></span><br><span class="line">toString(&#123;&#125;)     <span class="comment">// [object Object]</span></span><br><span class="line">toString(<span class="regexp">/.*/</span>)   <span class="comment">// [object RegExp]</span></span><br></pre></td></tr></table></figure><p>通过以上的代码, 使得 <code>toString</code> 方法更具 <strong>普适性</strong>, 不用再每次都写一连串的代码了哦~</p><h3 id="两者对比"><a href="#两者对比" class="headerlink" title="两者对比"></a>两者对比</h3><p>柯里化: 使得函数更加的具体, 功能更加单一<br>反柯里化: 扩大函数的执行范围, 更具备普适性. 非我之物, 为我所用.</p><h2 id="面向切面编程"><a href="#面向切面编程" class="headerlink" title="面向切面编程"></a>面向切面编程</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>(AOP)面向切面编程, 主要实现的目的是针对业务处理过程中的切面进行提取, 它所面对的是处理过程的某个步骤或者阶段, 以获得逻辑过程中各部分之间低耦合性的隔离效果. 也就是说, 在业务逻辑开始之前与结束之后进行操作, 不干扰业务逻辑的具体过程 - 原理就是使用了函数劫持</p><p>定义业务逻辑的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sayHi = <span class="function"><span class="params">name</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`Hi <span class="subst">$&#123;name&#125;</span>`</span>)</span><br><span class="line">sayHi(<span class="string">'quanquan'</span>)  <span class="comment">// Hi quanquan</span></span><br></pre></td></tr></table></figure><p>劫持函数, 并添加函数执行前的逻辑</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里利用了箭头函数来保证 this 函数执行时上下文是正确的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        cb(...args)</span><br><span class="line">        <span class="keyword">this</span>(...args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newSayHi = sayHi.before(<span class="function"><span class="params">name</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`Hi before <span class="subst">$&#123;name&#125;</span>`</span>))</span><br><span class="line">newSayHi(<span class="string">'quanquan'</span>)</span><br><span class="line"><span class="comment">// Hi before quanquan</span></span><br><span class="line"><span class="comment">// Hi quanquan</span></span><br></pre></td></tr></table></figure><p>劫持函数, 并添加函数执行后的逻辑</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里利用了箭头函数来保证 this 函数执行时上下文是正确的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>(...args)</span><br><span class="line">        cb(...args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newSayHiAfter = newSayHi.after(<span class="function"><span class="params">name</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`Hi after <span class="subst">$&#123;name&#125;</span>`</span>))</span><br><span class="line">newSayHiAfter(<span class="string">'quanquan'</span>)</span><br><span class="line"><span class="comment">// Hi before quanquan</span></span><br><span class="line"><span class="comment">// Hi quanquan</span></span><br><span class="line"><span class="comment">// Hi after quanquan</span></span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures" target="_blank" rel="noopener">闭包</a></li><li><a href="https://zhuanlan.zhihu.com/p/31271179" target="_blank" rel="noopener">JavaScript函数柯里化</a></li><li><a href="https://www.jianshu.com/p/2975c25e4d71" target="_blank" rel="noopener">详解JS函数柯里化</a></li><li><a href="https://www.cnblogs.com/walls/p/9357818.html" target="_blank" rel="noopener">柯里化与反柯里化</a></li></ul></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84/" rel="tag"># 前端架构</a> <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag"># 学习笔记</a></div><div class="post-nav"><div class="post-nav-item"><a href="/%E5%89%8D%E7%AB%AF/interview/interview-7/" rel="prev" title="interview-7"><i class="fa fa-chevron-left"></i> interview-7</a></div><div class="post-nav-item"> <a href="/Tips/tips/brew-%E5%AE%89%E8%A3%85%E5%BA%94%E7%94%A8%E5%85%8D%E7%AD%89%E5%BE%85-Updating-Homebrew/" rel="next" title="brew 安装应用免等待 Updating Homebrew...">brew 安装应用免等待 Updating Homebrew...<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div><script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#概念"><span class="nav-text">概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#闭包"><span class="nav-text">闭包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#保存变量"><span class="nav-text">保存变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#封装类型判断的函数"><span class="nav-text">封装类型判断的函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#保护局部变量"><span class="nav-text">保护局部变量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#柯里化-反柯里化"><span class="nav-text">柯里化 | 反柯里化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#柯里化"><span class="nav-text">柯里化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#函数柯里化的作用"><span class="nav-text">函数柯里化的作用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#参数复用"><span class="nav-text">参数复用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#延迟执行"><span class="nav-text">延迟执行</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#提前求值"><span class="nav-text">提前求值</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#反柯里化"><span class="nav-text">反柯里化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#两者对比"><span class="nav-text">两者对比</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面向切面编程"><span class="nav-text">面向切面编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概念-1"><span class="nav-text">概念</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考文档"><span class="nav-text">参考文档</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="圈圈的圈" src="/images/avatar.jpeg"><p class="site-author-name" itemprop="name">圈圈的圈</p><div class="site-description" itemprop="description">技术学习, 读书笔记, 生活感悟~</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">51</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">9</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">36</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://juejin.im/user/5837c2bd61ff4b006ca8d1b2" title="掘金 → https:&#x2F;&#x2F;juejin.im&#x2F;user&#x2F;5837c2bd61ff4b006ca8d1b2" rel="noopener" target="_blank"><i class="fa fa-fw fa-stack-overflow"></i> 掘金</a></span><span class="links-of-author-item"><a href="https://github.com/luoquanquan" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;luoquanquan" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:luo_quanquan@163.com" title="E-Mail → mailto:luo_quanquan@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i> E-Mail</a></span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-fw fa-rss"></i> RSS</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="http://www.beian.miit.gov.cn/" rel="noopener" target="_blank">京ICP备17034706号-1</a></div><div class="copyright"> &copy; <span itemprop="copyrightYear">2021</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">圈圈的圈</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-area-chart"></i></span> <span title="站点总字数">79k</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span title="站点阅读时长">1:12</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span> <span class="post-meta-divider">|</span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/js/theme-next-canvas-nest/canvas-nest.min.js"></script><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script></body></html>