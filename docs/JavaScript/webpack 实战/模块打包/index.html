<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 4.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon-1.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-1.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-1.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:new URL("http://note.niubishanshan.top").hostname,root:"/",scheme:"Gemini",version:"7.7.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{appID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},path:"search.json",motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}}}</script><meta name="description" content="webpack 实战 第二章学习笔记  模块的概念模块相之于程序, 就如同细胞之于生物体, 是具有特定功能的组成单元. 不同的模块负责不同的工作. 他们以某种方式联系在一起, 共同保证了程序的正常工作."><meta property="og:type" content="article"><meta property="og:title" content="模块打包"><meta property="og:url" content="http://note.niubishanshan.top/JavaScript/webpack%20%E5%AE%9E%E6%88%98/%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85/index.html"><meta property="og:site_name" content="圈圈的随手笔记"><meta property="og:description" content="webpack 实战 第二章学习笔记  模块的概念模块相之于程序, 就如同细胞之于生物体, 是具有特定功能的组成单元. 不同的模块负责不同的工作. 他们以某种方式联系在一起, 共同保证了程序的正常工作."><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2020-02-25T09:10:31.000Z"><meta property="article:modified_time" content="2020-03-08T09:37:53.634Z"><meta property="article:author" content="圈圈的圈"><meta property="article:tag" content="webpack"><meta name="twitter:card" content="summary"><link rel="canonical" href="http://note.niubishanshan.top/JavaScript/webpack%20%E5%AE%9E%E6%88%98/%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0}</script><title>模块打包 | 圈圈的随手笔记</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="圈圈的随手笔记" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div> <a href="https://github.com/luoquanquan" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513;color:#fff;position:absolute;top:0;border:0;right:0" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">圈圈的随手笔记</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">路漫漫其修远兮, 吾将上下而求索</p></div><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i> 首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i> 归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i> 关于</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="site-search"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="搜索..." spellcheck="false" type="text" id="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"></div></div><div class="search-pop-overlay"></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content"><div class="posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://note.niubishanshan.top/JavaScript/webpack%20%E5%AE%9E%E6%88%98/%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpeg"><meta itemprop="name" content="圈圈的圈"><meta itemprop="description" content="技术学习, 读书笔记, 生活感悟~"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="圈圈的随手笔记"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> 模块打包</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-02-25 17:10:31" itemprop="dateCreated datePublished" datetime="2020-02-25T17:10:31+08:00">2020-02-25</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-03-08 17:37:53" itemprop="dateModified" datetime="2020-03-08T17:37:53+08:00">2020-03-08</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a></span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>8.8k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span>8 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><blockquote><p><a href="https://item.jd.com/12623590.html" target="_blank" rel="noopener">webpack 实战</a> 第二章学习笔记</p></blockquote><h2 id="模块的概念"><a href="#模块的概念" class="headerlink" title="模块的概念"></a>模块的概念</h2><p>模块相之于程序, 就如同细胞之于生物体, 是具有特定功能的组成单元. 不同的模块负责不同的工作. 他们以某种方式联系在一起, 共同保证了程序的正常工作.</p><a id="more"></a><h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>CommonJS 是由 JavaScript 社区于 2009 年提出的包含模块 文件 控制台在内的一系列标准.</p><p>CommonJS 最初只为了服务端而设计, 直到有了 browserify 可以将 CommonJS 模块打包为浏览器可以运行的单个文件. 意味着客户端也可以遵循 CommonJS 标准来编写模块代码了</p><h3 id="对比直接插入-script-标签"><a href="#对比直接插入-script-标签" class="headerlink" title="对比直接插入 script 标签"></a>对比直接插入 script 标签</h3><p>CommonJS 中规定每个文件就是一个模块, 他与直接使用 script 标签将 js 文件引入的区别主要是, 直接引入的方式 js 文件的顶级作用域是全局作用域 在进行变量及函数声明时会污染全局环境, 后者则会形成一个属于模块自身的作用域, 模块内的函数和变量只有模块内部可以访问, 对外是不可见的</p><p>例如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// calculator.js</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'calculator.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'index.js'</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./calculator.js'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// index.js</span></span><br></pre></td></tr></table></figure><p>上述代码会输出 <code>index.js</code> 说明了 <code>calculator.js</code> 中的变量声明不会影响 <code>index.js</code>, 每个模块都是有自己的作用域的.</p><h3 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h3><p>由于模块外部不能访问到模块内的内容所以模块想要像外界暴露自身的唯一方式就是导出, CommonJS 中通过 module.exports 向外暴露内容.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    name: <span class="string">'calculator.js'</span>,</span><br><span class="line">    add(a, b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CommonJS 内部使用 module 对象用于存放当前模块的信息, 可以理解为模块最开始定义了一下变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = &#123;&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>module.exports</code> 定义了模块向外部导出的内容, 为了书写的方便. CommonJS 提供了以下简写方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">exports.name = <span class="string">'calculator.js'</span></span><br><span class="line">exports.add = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码和 <code>module.exports</code> 导出方式在实现效果上没有任何的区别, 其中的机制是将 <code>exports</code> 指向了 <code>module.exports</code>, 而 <code>module.exports</code> 初始化时指向了一个空对象. 可以理解为 CommonJS 默认在每个模块的首部添加了以下代码.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">    exports: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> exports = <span class="built_in">module</span>.exports</span><br></pre></td></tr></table></figure><p>所以 <code>exports.add</code> 相当于给 <code>module.exports</code> 添加了一个属性</p><p>PS: 使用 <code>exports</code> 时需要注意, 不能直接给 <code>exports</code> 否则会使其失效</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exports = &#123;</span><br><span class="line">    name: <span class="string">'calculator.js'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时, 只是修改了 <code>exports</code> 的值, 但是 <code>module.exports</code> 却仍然指向原来的对象, 因此 <code>name</code> 属性不会被导出</p><p>还有一个常见的错位用法是将 <code>exports</code> 和 <code>module.exports</code> 混用.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">exports.add = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">modules.exports = &#123;</span><br><span class="line">    name: <span class="string">'calculator.js'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中, 首先用 <code>exports</code> 导出了 add 属性, 然后将 <code>module.exports</code> 重新赋值为另外一个对象. 这会导致原本拥有的 add 属性丢失掉了, 最终只有 name 成功导出.</p><p>还要注意, 导出语句不代表模块的末尾, 在 <code>module.exports</code> 或 <code>exports</code> 后边的代码也是会执行的, 比如下面的代码会成功打印出 end</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    name: <span class="string">'calculator.js'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end'</span>)</span><br></pre></td></tr></table></figure><h3 id="导入-require"><a href="#导入-require" class="headerlink" title="导入 require"></a>导入 require</h3><p>在 CommonJS 中需要使用 require 导入模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// calculator.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    add: <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> calculator = <span class="built_in">require</span>(<span class="string">'./calculator.js'</span>)</span><br><span class="line"><span class="keyword">const</span> sum = calculator.add(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(sum) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>上述示例中, 在 <code>index.js</code> 中到入了 calculator 还使用了它的 add 方法</p><h4 id="导入一个模块的两种情况"><a href="#导入一个模块的两种情况" class="headerlink" title="导入一个模块的两种情况"></a>导入一个模块的两种情况</h4><ul><li>require 的模块是第一次被加载, 这时会首先执行该模块, 然后导出内容</li><li>require 的模块曾被加载过, 这时该模块的代码不会再次执行, 而是直接导出上次加载时执行的结果</li></ul><h4 id="不需要获取导出内容的导入"><a href="#不需要获取导出内容的导入" class="headerlink" title="不需要获取导出内容的导入"></a>不需要获取导出内容的导入</h4><p>如果需要加载一个模块但是不需要获取其导出的内容, 只是想要通过执行它而产生某种作用(比如 polyfill) 此时只需要执行 require 语句, 无需赋值操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'babel-polyfill'</span>)</span><br></pre></td></tr></table></figure><h4 id="动态加载路径"><a href="#动态加载路径" class="headerlink" title="动态加载路径"></a>动态加载路径</h4><p>require 还支持接收表达式模块路径. 因此, 我们可以动态地指定模块加载的路径</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleNames = [<span class="string">'foo.js'</span>, <span class="string">'bar.js'</span>]</span><br><span class="line">moduleNames.forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">`./<span class="subst">$&#123;name&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="ES6-Module"><a href="#ES6-Module" class="headerlink" title="ES6 Module"></a>ES6 Module</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>2015 年 6 月, 由 TC39 标准 委员会正式发布了 ES6, JavaScript 才拥有了模块化的能力</p><h3 id="语法示例"><a href="#语法示例" class="headerlink" title="语法示例"></a>语法示例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// calculator.js</span></span><br><span class="line">exports <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">'calculator.js'</span>,</span><br><span class="line">    add: <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> calculator <span class="keyword">from</span> <span class="string">'./calculator.js'</span></span><br><span class="line"><span class="keyword">const</span> sum = calculator.add(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(sum) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h3 id="和-CommonJS-的异同"><a href="#和-CommonJS-的异同" class="headerlink" title="和 CommonJS 的异同"></a>和 CommonJS 的异同</h3><p>相同点:</p><ul><li>ES Module 也是把每个文件都当做一个模块, 每个模块拥有自身的作用域</li></ul><p>不同点:</p><ul><li>和 CommonJS 不同的地方是导入和导出的语句</li><li><code>import</code> 和 <code>export</code> 也在 ES6 确认为保留关键字(CommonJS 中的 module 不属于保留关键字)</li><li>ES6 Module 会自动采用严格模式, 这在 ES5(CommonJS) 中是一个可选项.</li></ul><h3 id="导出-1"><a href="#导出-1" class="headerlink" title="导出"></a>导出</h3><ul><li>命名导出</li><li>默认导出</li></ul><h4 id="命名导出"><a href="#命名导出" class="headerlink" title="命名导出"></a>命名导出</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法 1</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">'calculator'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> add = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法 2</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">'calculator'</span></span><br><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b</span><br><span class="line"><span class="keyword">export</span> &#123;name, add&#125;</span><br></pre></td></tr></table></figure><p>使用命名导出时还可以使用 as 进行重命名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">'calculator'</span></span><br><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b</span><br><span class="line"><span class="keyword">export</span> &#123;name, add <span class="keyword">as</span> getSum&#125;</span><br></pre></td></tr></table></figure><h4 id="默认导出"><a href="#默认导出" class="headerlink" title="默认导出"></a>默认导出</h4><p>对于默认输出可以理解为对外输出了一个名为 <code>default</code> 的变量, 因此不需要像命名导出一样进行变量声明, 直接导出即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">'calculator'</span>,</span><br><span class="line">    add: <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><p>ES6 Module 中使用 import 导入模块, 导入的内容定义的变量是只读的, 不能进行修改.</p><ul><li>导入带有命名导出的模块</li><li>导入默认导出的模块</li><li>导入两种导出模式混用的模块</li></ul><h4 id="导入带有命名导出的模块"><a href="#导入带有命名导出的模块" class="headerlink" title="导入带有命名导出的模块"></a>导入带有命名导出的模块</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// calculator.js</span></span><br><span class="line">exports <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">'calculator.js'</span>,</span><br><span class="line">    add: <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;name, add&#125; <span class="keyword">from</span> <span class="string">'./calculator.js'</span></span><br><span class="line"><span class="keyword">const</span> sum = add(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(sum) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>与命名导出类似, 可以通过 as 关键字对导入的变量重新命名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;name, add <span class="keyword">as</span> getSum&#125; <span class="keyword">from</span> <span class="string">'./calculator.js'</span></span><br><span class="line"><span class="keyword">const</span> sum = getSum(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(sum) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>在导入多个变量时还可以采用整体导入的方式, 使用整体导入的方式把所有导入的值作为属性值添加给导入变量, 能够减少模块导入对当前模块的命名空间的影响.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> calculator <span class="keyword">from</span> <span class="string">'./calculator.js'</span></span><br><span class="line"><span class="keyword">const</span> sum = calculator.add(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(sum) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h4 id="导入默认导出的模块"><a href="#导入默认导出的模块" class="headerlink" title="导入默认导出的模块"></a>导入默认导出的模块</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// calculator.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">'calculator'</span>,</span><br><span class="line">    add: <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> calculator <span class="keyword">from</span> <span class="string">'./calculator.js'</span></span><br><span class="line">calculator(<span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>对于默认导出的模块, import 后边直接跟变量名, 并且这个变量名可以自由指定. 用于指代 calculator.js 导出的值, 原理如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> calculator&#125; <span class="keyword">from</span> <span class="string">'./calculator.js'</span></span><br></pre></td></tr></table></figure><h4 id="导入两种导出模式混用的模块"><a href="#导入两种导出模式混用的模块" class="headerlink" title="导入两种导出模式混用的模块"></a>导入两种导出模式混用的模块</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br></pre></td></tr></table></figure><p>以上 demo 中 React 是 react 模块的默认导出, Component 则是命名导出的一个变量</p><p>PS: 这里的 React 一定要写在 大括号的左边, 否则会报语法错误…</p><h3 id="复合导出和导入"><a href="#复合导出和导入" class="headerlink" title="复合导出和导入"></a>复合导出和导入</h3><p>在实际项目中, 经常需要把某一个模块导入以后立即导出(组件入口), 此时可以使用复合模式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;name, add&#125; <span class="keyword">from</span> <span class="string">'./calculator.js'</span></span><br></pre></td></tr></table></figure><p>复合写法, 目前只支持被导入模块通过命名导出的方式导出的变量, 默认导出则没有对应的复合语法, 需要分为两步.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> calculator <span class="keyword">from</span> <span class="string">'./calculator.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> calculator</span><br></pre></td></tr></table></figure><h2 id="CommonJS-和-ES6-Module-的区别"><a href="#CommonJS-和-ES6-Module-的区别" class="headerlink" title="CommonJS 和 ES6 Module 的区别"></a>CommonJS 和 ES6 Module 的区别</h2><ul><li>动态与静态</li><li>值拷贝和动态映射</li><li>循环依赖</li></ul><h3 id="动态与静态"><a href="#动态与静态" class="headerlink" title="动态与静态"></a>动态与静态</h3><p>CommonJS 对模块依赖的解决是<strong>动态</strong>的, 而 ES6 Module 是<strong>静态</strong>的. 其中, 动态表示模块依赖关系的建立发生在代码的<strong>运行阶段</strong>, 而静态则表示模块依赖关系的建立发生在代码的<strong>编译阶段</strong>.</p><p>首先看一个 CommonJS 的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;<span class="attr">name</span>: <span class="string">'b'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="built_in">require</span>(<span class="string">'./b.js'</span>).name</span><br></pre></td></tr></table></figure><p>模块 a 加载模块 b 时, 会先执行 b 中的代码, 并将其 <code>module.exports</code> 作为 require 的返回值. 并且 require 模块的路径可以动态指定, 支持传入一个表达式. 甚至可以通过 if 语句判断是否加载某个模块. 故, 代码执行前不能明确代码之间的依赖关系, 模块的导入导出发生在代码的运行阶段.</p><p>再看一个 ES6 Module 的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">'b'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;name&#125; <span class="keyword">from</span> <span class="string">'./b.js'</span></span><br></pre></td></tr></table></figure><p>ES6 Module 的导入和导出语句都是声明式的, 不能够支持路径是一个表达式. 并且导入和导出语句必须在模块的顶层作用域(不能在 if 语句中). 故, ES6 Module 是一种静态的模块结构, 在 ES6 代码的编译阶段就能分析出模块的依赖关系.</p><p>相对于 CommonJS 动态导入类型优势</p><ul><li>死代码检测和排除</li><li>可实现模块变量类型检查</li><li>编译器优化, 在 CommonJS 等动态模块化系统中, 无论采用哪种方式, 本质上导入的都是一个对象. 而 es6 支持直接导入变量, 减少了引用的层级. 程序效率更高</li></ul><h3 id="值拷贝和动态映射"><a href="#值拷贝和动态映射" class="headerlink" title="值拷贝和动态映射"></a>值拷贝和动态映射</h3><p>导入一个模块时, CommonJS 方案获取的是一份导出<strong>值的拷贝</strong>, 而在 ES6 Module 中获得的则是<strong>值的动态映射</strong>且这个映射是只读的.</p><p>首先看一个 CommonJS 的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.js</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    count,</span><br><span class="line">    add(a, b) &#123;</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bar.js</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="built_in">require</span>(<span class="string">'./foo.js'</span>).count</span><br><span class="line"><span class="keyword">var</span> add = <span class="built_in">require</span>(<span class="string">'./foo.js'</span>).add</span><br><span class="line"><span class="built_in">console</span>.log(count) <span class="comment">// 0 这里的 count 是对 foo.js 中的 count 值的拷贝</span></span><br><span class="line">add(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(count) <span class="comment">// 0 foo.js 中的 count 的变化不会改变导入的 count 的值</span></span><br><span class="line">count += <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(count) <span class="comment">// 1 导入的 count 变量, 也就是拷贝的值可以更改</span></span><br></pre></td></tr></table></figure><p><code>bar.js</code> 中的 count 是对 <code>foo.js</code> 中的 count 值的一份值拷贝, 因此在调用 add 函数时, 虽然改变了 <code>foo.js</code> 中的 count 的值但是并没有对 bar 中导入是创建的副本造成影响. 同时, 在 CommonJS 中允许我们对导入的值进行修改. 可以修改 <code>bar.js</code> 中导入的 count 的值, 当然由于是值的拷贝, 这些操作也不会影响到 <code>bar.js</code> 本身.</p><p>其次, 看一个 ES6 Module 的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.js</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;count, add&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bar.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;count, add&#125; <span class="keyword">from</span> <span class="string">'./foo.js'</span></span><br><span class="line"><span class="built_in">console</span>.log(count) <span class="comment">// 0 这里的 count 是对 foo.js 中的 count 值的映射</span></span><br><span class="line">add(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(count) <span class="comment">// 1 实时反映 foo.js 中的 count 值的变化</span></span><br><span class="line">count += <span class="number">1</span> <span class="comment">// 不可更改, 抛出 SyntaxError</span></span><br></pre></td></tr></table></figure><p>ES6 Module 中导入的变量, 其实就是对原有值的<strong>动态映射</strong> <code>bar.js</code> 中导入的 count 就是 <code>foo.js</code> 中的 count 变量值的<strong>实时反映</strong>, 通过使用 add 方法修改了 <code>foo.js</code> 中的 count 变量, <code>bar.js</code> 中导入的 count 变量值也随之变化.</p><h3 id="循环依赖代码示例"><a href="#循环依赖代码示例" class="headerlink" title="循环依赖代码示例"></a>循环依赖<a href="https://github.com/luoquanquan/learn-fe/tree/master/webpack-learn/webpack-in-action/circular-reference" target="_blank" rel="noopener">代码示例</a></h3><p>循环依赖指的是 a 依赖 b, 同时 b 又依赖 a, 比如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;bar&#125; <span class="keyword">from</span> <span class="string">'./bar.js'</span></span><br><span class="line">bar()</span><br><span class="line"></span><br><span class="line"><span class="comment">// bar.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="string">'./foo.js'</span></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>工程项目中应该避免循环依赖的产生, 但是实际项目复杂度上升的时候容易出现隐藏的循环依赖关系…</p><p>首先看一个 CommonJS 的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.js</span></span><br><span class="line"><span class="keyword">const</span> bar = <span class="built_in">require</span>(<span class="string">'./bar.js'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'value of bar: '</span>, bar)</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="string">'this is foo.js'</span></span><br><span class="line"><span class="comment">// bar.js</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="built_in">require</span>(<span class="string">'./foo.js'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'value of foo: '</span>, foo)</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="string">'this is bar.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./foo.js'</span>)</span><br></pre></td></tr></table></figure><p>上例中, <code>index.js</code> 是程序执行的入口. 它加载了 <code>foo.js</code> 然而 <code>foo.js</code> 和 <code>bar.js</code> 存在循环依赖关系, 理想情况下, 两个模块都能正常执行控制台输出以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value of foo: this is foo.js</span><br><span class="line">value of bar: this is bar.js</span><br></pre></td></tr></table></figure><p>然而实际是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value of foo:  &#123;&#125;</span><br><span class="line">value of bar:  this is bar.js</span><br></pre></td></tr></table></figure><p>上述代码的执行过程为:</p><ol><li><code>index.js</code> 导入了 <code>foo.js</code>, 此时开始执行 <code>foo.js</code> 中的代码</li><li><code>foo.js</code> 第一行导入了 <code>bar.js</code>, 这时 <code>foo.js</code> 不会继续向下执行, 而是进入 <code>bar.js</code> 内部</li><li>在 <code>bar.js</code> 中又对 <code>foo.js</code> 进行了导入, 产生循环依赖.</li><li>然而此时由于 <code>foo.js</code> 已经被导入过一次, 执行权不会再次给到 <code>foo.js</code> 而是直接取其导出值, 也就是 <code>module.exports</code> 但是 <code>foo.js</code> 还没有执行完毕导出值此时为默认的空对象, 所以 <code>bar.js</code> 中的打印语句打印的结果是 <code>value of foo: {}</code></li><li><code>bar.js</code> 执行完毕, 执行权交回 <code>foo.js</code>, 在 <code>foo.js</code> 中继续向下执行, 在控制台中打印出 <code>value of bar: this is bar.js</code> 整个流程结束</li></ol><p>通过以上流程可知, CommonJS 中遇到循环依赖, 虽然模块都会执行, 但是并不能获取到我们想要的结果. 通过 webpack 生成代码的这一段可以理解以上第四步的内容, 当然也可以在 nodejs 模块的 require 函数前打点, 进入函数内部研究一把. 道理是一样的,</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// Check if module is in cache</span></span><br><span class="line">	<span class="keyword">if</span>(installedModules[moduleId]) &#123;</span><br><span class="line">		<span class="keyword">return</span> installedModules[moduleId].exports;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Create a new module (and put it into the cache)</span></span><br><span class="line">	<span class="keyword">var</span> <span class="built_in">module</span> = installedModules[moduleId] = &#123;</span><br><span class="line">		i: moduleId,</span><br><span class="line">		l: <span class="literal">false</span>,</span><br><span class="line">		exports: &#123;&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Execute the module function</span></span><br><span class="line">	modules[moduleId].call(<span class="built_in">module</span>.exports, <span class="built_in">module</span>, <span class="built_in">module</span>.exports, __webpack_require__);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Flag the module as loaded</span></span><br><span class="line">	<span class="built_in">module</span>.l = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Return the exports of the module</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次, 看一个 ES6 Module 循环依赖的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.js</span></span><br><span class="line"><span class="keyword">import</span> bar <span class="keyword">from</span> <span class="string">'./bar'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'value of bar: '</span>, bar)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="string">'this is foo.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bar.js</span></span><br><span class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">'./foo'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'value of foo: '</span>, foo)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="string">'this is bar.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./foo.js'</span></span><br></pre></td></tr></table></figure><p>由于 node 不能支持 <code>ES6 Module</code>, 所以需要使用 parcel 做一下打包处理, 详细代码在<a href="https://github.com/luoquanquan/learn-fe/tree/master/webpack-learn/webpack-in-action/circular-reference/es6-module" target="_blank" rel="noopener">这里</a></p><p>输出的结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value of foo:  undefined</span><br><span class="line">foo.js:2 value of bar:  this is bar.js</span><br></pre></td></tr></table></figure><p><code>ES6 Module</code> 中也不能得到预想的值, 但是和 <code>CommonJS</code> 有区别, 在于 <code>CommonJS</code> 循环依赖得到的是一个空对象而 <code>ES6 Module</code> 得到的是 undefined.</p><p>利用 <code>ES6 Module</code> 获取到的值是模块的动态映射的特性使其支持循环依赖</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.js</span></span><br><span class="line"><span class="keyword">import</span> bar <span class="keyword">from</span> <span class="string">'./bar'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">invoker</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(invoker, <span class="string">' invokes foo.js'</span>)</span><br><span class="line">    bar(<span class="string">'foo.js'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> foo</span><br><span class="line"></span><br><span class="line"><span class="comment">// bar.js</span></span><br><span class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">'./foo'</span></span><br><span class="line"><span class="keyword">let</span> invoked = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">invoker</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!invoked) &#123;</span><br><span class="line">        invoked = <span class="literal">true</span></span><br><span class="line">        <span class="built_in">console</span>.log(invoker, <span class="string">' invokes bar.js'</span>)</span><br><span class="line">        foo(<span class="string">'bar.js'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> bar</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">'./foo.js'</span></span><br><span class="line">foo(<span class="string">'index.js'</span>)</span><br></pre></td></tr></table></figure><p>以上代码运行的结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">index.js  invokes foo.js</span><br><span class="line">bar.js:7 foo.js  invokes bar.js</span><br><span class="line">foo.js:3 bar.js  invokes foo.js</span><br></pre></td></tr></table></figure><p>综上, <code>foo.js</code> 和 <code>bar.js</code> 两个模块均获取了正确的导出值, 代码执行的过程为.</p><ol><li><code>index.js</code> 作为入口导入 <code>foo.js</code>, 开始执行 <code>foo.js</code> 中的代码</li><li><code>foo.js</code> 中导入了 <code>bar.js</code> 执行权交给 <code>bar.js</code></li><li>在 <code>bar.js</code> 中一直执行到其结束, 完成 bar 函数的定义, 此时 <code>foo.js</code> 还没有执行完, 所以 foo 还是 undefined</li><li>执行权回到 <code>foo.js</code> 继续执行直到结束, 完成 foo 函数的定义, 由于 <code>ES6 Module</code> 的动态特性, 此时 <code>bar.js</code> 中的 foo 变量也已经有值. 这是两中模块加载方式的本质区别</li><li>执行权回到 <code>index.js</code> 并执行 foo 函数, 此时依次执行 <code>foo -&gt; bar -&gt; foo</code>, 并在控制台打印出预想的值</li></ol></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/webpack/" rel="tag"># webpack</a></div><div class="post-nav"><div class="post-nav-item"><a href="/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%AD%E7%BB%83%E8%AF%BE-%E7%AC%94%E8%AE%B0/%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E/url%20%E8%B7%B3%E8%BD%AC%E6%BC%8F%E6%B4%9E/" rel="prev" title="URL 跳转漏洞"><i class="fa fa-chevron-left"></i> URL 跳转漏洞</a></div><div class="post-nav-item"> <a href="/Tips/tips/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B0%8F%E5%9D%91/" rel="next" title="常见的小坑">常见的小坑<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div><script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#模块的概念"><span class="nav-text">模块的概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CommonJS"><span class="nav-text">CommonJS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概念"><span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对比直接插入-script-标签"><span class="nav-text">对比直接插入 script 标签</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#导出"><span class="nav-text">导出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#导入-require"><span class="nav-text">导入 require</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#导入一个模块的两种情况"><span class="nav-text">导入一个模块的两种情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不需要获取导出内容的导入"><span class="nav-text">不需要获取导出内容的导入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动态加载路径"><span class="nav-text">动态加载路径</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ES6-Module"><span class="nav-text">ES6 Module</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概念-1"><span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#语法示例"><span class="nav-text">语法示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#和-CommonJS-的异同"><span class="nav-text">和 CommonJS 的异同</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#导出-1"><span class="nav-text">导出</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命名导出"><span class="nav-text">命名导出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#默认导出"><span class="nav-text">默认导出</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#导入"><span class="nav-text">导入</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#导入带有命名导出的模块"><span class="nav-text">导入带有命名导出的模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#导入默认导出的模块"><span class="nav-text">导入默认导出的模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#导入两种导出模式混用的模块"><span class="nav-text">导入两种导出模式混用的模块</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复合导出和导入"><span class="nav-text">复合导出和导入</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CommonJS-和-ES6-Module-的区别"><span class="nav-text">CommonJS 和 ES6 Module 的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#动态与静态"><span class="nav-text">动态与静态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#值拷贝和动态映射"><span class="nav-text">值拷贝和动态映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#循环依赖代码示例"><span class="nav-text">循环依赖代码示例</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="圈圈的圈" src="/images/avatar.jpeg"><p class="site-author-name" itemprop="name">圈圈的圈</p><div class="site-description" itemprop="description">技术学习, 读书笔记, 生活感悟~</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">46</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">7</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">26</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://juejin.im/user/5837c2bd61ff4b006ca8d1b2" title="掘金 → https:&#x2F;&#x2F;juejin.im&#x2F;user&#x2F;5837c2bd61ff4b006ca8d1b2" rel="noopener" target="_blank"><i class="fa fa-fw fa-stack-overflow"></i> 掘金</a></span><span class="links-of-author-item"><a href="https://github.com/luoquanquan" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;luoquanquan" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:luo_quanquan@163.com" title="E-Mail → mailto:luo_quanquan@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i> E-Mail</a></span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-fw fa-rss"></i> RSS</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="http://www.beian.miit.gov.cn/" rel="noopener" target="_blank">京ICP备17034706号-1</a></div><div class="copyright"> &copy; <span itemprop="copyrightYear">2020</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">圈圈的圈</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-area-chart"></i></span> <span title="站点总字数">68k</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span title="站点阅读时长">1:02</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span> <span class="post-meta-divider">|</span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/js/theme-next-canvas-nest/canvas-nest.min.js"></script><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script></body></html>